---
title: "Engineering and shaping data"
format: gfm
---

```{r, setup, include=FALSE}
knitr::opts_chunk$set(paged.print = FALSE)
```


# Data selection

## Subsetting rows and columns

```{r}
#| message: false
library(ggplot2)
library(magrittr)
summary(iris)
head(iris)
```

```{r pracr-5-eng-1}
#| warning: false
ggplot(iris, aes(x = Petal.Length, y = Petal.Width)) +
  geom_point(aes(color = Species, shape = Species), size = 2) +
  ggtitle("Petal dimensions by iris species")
```

Suppose we are assigned to generate a report on only petal length and petal width, by iris species, for irises where the petal length is greater than 2.

> With R

```{r}
iris[iris$Petal.Length > 2, c("Petal.Length", "Petal.Width", "Species")] %>% 
  head()
```

> With `data.table`

```{r}
#| message: false
library(data.table)
iris_dt <- as.data.table(iris)

cols <- c("Petal.Length", "Petal.Width", "Species")
iris_dt <- iris_dt[iris_dt$Petal.Length > 2, ..cols]
head(iris_dt)
```

> `dplyr`

```{r}
#| message: false
library(dplyr)
iris_dplyr <- iris %>% 
  select(., Petal.Length, Petal.Width, Species) %>% 
  filter(., Petal.Length > 2)
head(iris_dplyr)
```

## Removing incomplete records

```{r}
str(msleep)
summary(msleep)
```

Remove all rows with missing values

> Base R

```{r}
# clean_base_1 <- msleep[complete.cases(msleep), , drop = FALSE]
clean_base_2 <- na.omit(msleep)
head(clean_base_2)
nrow(clean_base_2)
```

> `data.table`

```{r}
msleep_dt <- as.data.table(msleep)
clean_dt <- msleep_dt[complete.cases(msleep_dt),]
nrow(clean_dt)
```

> `dplyr`

```{r}
clean_dplyr <- msleep %>% 
  filter(., complete.cases(.))
nrow(clean_dplyr)
```

## Ordering rows

```{r}
purchases <- data.frame(
  day = c(1, 2, 2, 1, 2, 1),
  hour = c(9, 9, 11, 13, 13, 14),
  n_purchase = c(5, 3, 5, 1, 3, 1)
)
```

Order by hour and compute running sum

> base R

```{r}
idx <- with(purchases, order(day, hour))
purchases_ordered <- purchases[idx, , drop = F]
purchases_ordered$running_total <- cumsum(purchases_ordered$n_purchase)
head(purchases_ordered)
```

> `data.table`

```{r}
purchases_dt <- as.data.table(purchases)
setorderv(purchases_dt, c("day", "hour"))
purchases_dt[, running_total := cumsum(n_purchase)]
head(purchases_dt)
```


> `dplyr`

```{r}
purchases %>% 
  arrange(day, hour) %>% 
  mutate(running_total = cumsum(n_purchase))
```

__Calculate the running total per day__

> R base

Too complicated

> `data.table`

```{r}
purchases_dt <- as.data.table(purchases)
purchases_dt[order(day, hour),
             .(hour = hour,
               n_purchase = n_purchase,
               running_total = cumsum(n_purchase)),
             by = day]
```

```{r}
setorderv(purchases_dt, c("day", "hour"))
purchases_dt[, running_total := cumsum(n_purchase), by = day]
head(purchases_dt)
```

Without reordering the table

```{r}
purchases_dt <- as.data.table(purchases)
purchases_dt[order(day, hour),
             `:=`(hour = hour,
                  n_purchase = n_purchase,
                  running_total = cumsum(n_purchase)),
             by = day]
head(purchases_dt)
```

> `dpylr`

```{r}
purchases %>% 
  arrange(day, hour) %>% 
  group_by(day) %>% 
  mutate(running_total = cumsum(n_purchase)) %>% 
  ungroup()
```

# Basic data transforms

```{r}
library(datasets)
summary(airquality)
```

## Create a date column

> base R

```{r}
#| message: false
library(lubridate)
datestr <-  function(day, month, year) {
  paste(day, month, year, sep="-")
  }
airquality_with_date <- airquality
airquality_with_date$date <- with(airquality_with_date,
                                  dmy(datestr(Day, Month, 1973)))
airquality_with_date[, c("Ozone", "date"), drop = F] %>% head()
```

```{r pracr-5-eng-2}
ggplot(airquality_with_date, aes(x = date, y = Ozone)) +
  geom_point() +
  geom_line() +
  xlab("Date") +
  ggtitle("New York ozone readings May 1 - Sep 30, 1973")
```

> `data.table`

```{r}
airquality_dt <- as.data.table(airquality)
airquality_dt[
  , date := dmy(datestr(Day, Month, 1973))][
    , c("Ozone", "date")
  ]
```

> `dplyr`

```{r}
airquality_with_date2 <- airquality %>% 
  mutate(date = dmy(datestr(Day, Month, 1973))) %>% 
  select(Ozone, date)
head(airquality_with_date2)
```

## Impute NAs

Propagate the last known Ozone reading forward

> Base R `na.locf()`

```{r}
#| message: false
library(zoo)
airquality_corrected <- airquality_with_date
airquality_corrected$OzoneCorrected <- 
  na.locf(airquality_corrected$Ozone, na.rm = F)
summary(airquality_corrected)
```


```{r pracr-5-eng-3}
ggplot(airquality_corrected, aes(x = date, y = Ozone)) +
  geom_point(aes(y = OzoneCorrected), colour = "pink") +
  geom_point(aes(y = Ozone)) +
  geom_line(aes(y = OzoneCorrected)) +
  ggtitle("New York ozone readings", subtitle = "(corrected)") +
  xlab("Date")
```

> `data.table`

```{r}
airquality_dt[, OzoneCorrected := na.locf(Ozone, na.rm = F)]
summary(airquality_dt)
```

> `dplyr`

```{r}
airquality_with_date %>% 
  mutate(OzoneCorrected = na.locf(Ozone, na.rm = F)) %>% 
  summary()
```

# Aggregating transforms

Summarizing rows

> Base R

```{r}
(iris_summary <- aggregate(
  cbind(Petal.Length, Petal.Width) ~ Species,
  data = iris, FUN = mean))
```

```{r pracr-5-eng-4}
ggplot(mapping = aes(x = Petal.Length, y = Petal.Width, 
           shape = Species, color = Species)) +
  geom_point(data = iris, alpha = 0.5) +
  geom_point(data = iris_summary, size = 5) +
  ggtitle("Average Petal dimensions by iris species\n(with raw data for refer
ence)")
```

> `data.table`

```{r}
iris_dt <- as.data.table(iris)
iris_dt[, .(Petal.Length = mean(Petal.Length),
            Petal.Width = mean(Petal.Width)),
        by = .(Species)]
```

> `dplyr`

```{r}
iris %>% 
  group_by(Species) %>% 
  summarize(Petal.Length = mean(Petal.Length),
            Petal.Width = mean(Petal.Width)) %>% 
  ungroup()
```

Adding the calculated values as columns

```{r}
iris_copy <- iris
iris_copy$mean_Petal.Length <- 
  ave(iris$Petal.Length, iris$Species, FUN = mean)
iris_copy$mean_Petal.Width <- 
  ave(iris$Petal.Width, iris$Species, FUN = mean)
head(iris_copy)
```

```{r}
iris_copy[floor(runif(10, 1, 200)),]
```

> `data.table`

```{r}
iris_dt <- as.data.table(iris)
iris_dt[, `:=`(mean_Petal.Length = mean(Petal.Length),
               mean_Petal.Width = mean(Petal.Width)),
        by = "Species"]
iris_dt[floor(runif(10, 1, 200)),]
```

> `dplyr`

```{r}
iris %>% 
  group_by(Species) %>% 
  mutate(
    mean_Petal.Length = mean(Petal.Length),
    mean_Petal.Width = mean(Petal.Width)
  ) %>% 
  ungroup() %>% 
  head()
```

# Multitable transforms

## Combining ordered data frames

```{r}
product_table <- data.frame(
  product_id = c("p1", "p2", "p3", "p4", "p5"),
  price = c(9.99, 16.29, 19.99, 5.49, 24.49)
)

sales_table <- data.frame(
  product_id = c("p1", "p2", "p3", "p4", "p5"),
  sold_store = c(6, 31, 30, 31, 43),
  sold_online = c(64, 1, 23, 67, 51)
)

product_table_2 <- data.frame(
  product_id = c("n1", "n2", "n3"),
  price = c(25.49, 33.99, 17.99)
)

product_table$product_id <- as.factor(product_table$product_id)
product_table_2$product_id <- as.factor(product_table_2$product_id)
```

### Appending rows

> Base R

```{r}
rbind(product_table, product_table_2)
```

> `data.table`

```{r}
rbindlist(list(product_table, product_table_2))
```

> `dplyr`

```{r}
bind_rows(list(product_table, product_table_2))
```

### Splitting tables

Add an extra extra column with the name of the source table

```{r}
product_table_marked <- product_table
product_table_marked$table <- "product_table"
product_table_2_marked <- product_table_2
product_table_2_marked$table <- "product_table_2"
rbind_base <- rbind(product_table_marked, product_table_2_marked)
```

Split them apart

```{r}
split(rbind_base, rbind_base$table)
```

> `data.table`

Calculate max price per group

```{r}
rbind_base_dt <- as.data.table(rbind_base)
f <- function(.BY, .SD) {
  max(.SD$price)
}
rbind_base_dt[, max_price := f(.BY, .SD), by = table]
rbind_base_dt
```

```{r}
rbind_base_dt <- as.data.table(rbind_base)
grouping_column <- "table"
rbind_base_dt[, max_price := max(price), by = eval(grouping_column)]
rbind_base_dt
```

```{r}
rbind_base_dt <- as.data.table(rbind_base)
grouping_column <- "table"
rbind_base_dt[, max_price := max(price), by = grouping_column]
rbind_base_dt
```

> `dplyr`

```{r}
rbind_base %>% 
  group_by(table) %>% 
  mutate(max_price = max(price)) %>% 
  ungroup()
```

### Appending columns

```{r}
dim(sales_table)
dim(product_table)
cbind(product_table, sales_table[, -1])
```

> `data.table`

```{r}
cbind(as.data.table(product_table),
      as.data.table(sales_table[, -1]))
```

```{r}
dplyr:: bind_cols(list(product_table, sales_table[, -1]))
```

## Joining tables

```{r}
product_table_2 <- product_table[c(1, 3:5),]
sales_table_2 <- data.table(
  product_id = product_table[1:4, "product_id"],
  units_sold = c(10, 43, 55, 8)
)
product_table_2
sales_table_2
```

### Left join

> Base R

```{r}
merge(product_table_2, sales_table_2,
      by = "product_id", all.x = T)
```

> `data.table`

```{r}
product_table_2_dt <- as.data.table(product_table_2)
sales_table_2_dt <- as.data.table(sales_table_2)
sales_table_2_dt[product_table_2_dt, on = "product_id"]
```

Using indexing

```{r}
joined_table <- product_table_2
joined_table$unitsSold <- sales_table_2$units_sold[match(joined_table$product_id,
                                                         sales_table_2$product_id)]
joined_table
```

```{r}
left_join(product_table_2, sales_table_2)
```

### Inner join

> Base R and `data.table`

```{r}
merge(product_table_2, sales_table_2, by = "product_id")
```

> `dplyr`

```{r}
inner_join(product_table_2, sales_table_2, by = "product_id")
```

### Full join

> Base R and `data.table`

```{r}
merge(product_table_2, sales_table_2, by = "product_id", all = T)
```

```{r}
full_join(product_table_2, sales_table_2, by = "product_id")
```

### Rolling joins with `data.table`

A rolling join is a type of join on an ordered column that gives us the most recent data available at the lookup time.

You are given historic stock trade and quote (bid/ask) data. You are asked to perform
the following analyses on the stock data: find what the bid and ask price were current
when each trade was performed. This involves using row order to indicate time, and
sharing information between rows.

```{r}
quotes <- data.table(
  bid = c(5, 5, 7, 8),
  ask = c(6, 6, 8, 10),
  bid_quantity = c(100, 100, 100, 100),
  ask_quantity = c(100, 100, 100, 100),
  when = as.POSIXct(strptime(
    c("2018-10-18 1:03:17",
      "2018-10-18 2:12:23",
      "2018-10-18 2:15:00",
      "2018-10-18 2:17:51"),
    "%Y-%m-%d %H:%M:%S")))
quotes
```

```{r}
trades <- data.table(
  trade_id = c(32525, 32526),
  price = c(5.5, 9),
  quantity = c(100, 200),
  when = as.POSIXct(strptime(
    c("2018-10-18 2:13:42",
      "2018-10-18 2:19:20"),
    "%Y-%m-%d %H:%M:%S")))
trades
```

```{r}
quotes[, quote_time :=when]
trades[, trade_time := when]
quotes[trades, on = "when", roll = T][
  , .(quote_time, bid, price, ask, trade_id, trade_time)
]
```

# Reshaping transformations

Moving data between rows and columns

## Wide to tall

Let’s work with measurements of vehicle drivers/passengers injured or killed, by month. The data includes additional information about fuel price and whether seat-belts are required by law. Relevant variables for this example:

- date—Year and month of measurement (numeric representation)
- DriversKilled—Car drivers killed
- front—Front seat passengers killed or seriously injured
- rear—Rear seat passengers killed or seriously injured
- law—Whether or not seatbelt law was in effect (0/1)

```{r}
#| message: false
#| warning: false
library(datasets)
library(xts)
```

```{r}
dates <- index(as.xts(time(Seatbelts)))
seatbelts <- data.frame(Seatbelts)
seatbelts$date <- dates
```

Extract two years

```{r}
seatbelts <- seatbelts[(seatbelts$date >= as.yearmon("Jan 1982")) &
                         (seatbelts$date <= as.yearmon("Dec 1983")), ,
                       drop = F]
seatbelts$date <- as.Date(seatbelts$date)
seatbelts$law <- ifelse(seatbelts$law == 1, "new law", "pre-law")
seatbelts <- seatbelts[, c("date", "DriversKilled", "front", "rear", "law")]
head(seatbelts)
```

```{r pracr-5-eng-5}
ggplot(seatbelts, aes(x = date, y = DriversKilled,
                      color = law, shape = law)) +
  geom_point() +
  geom_smooth(se = F) +
  ggtitle("UK car driver deaths by month")
```

Include seating position in analysis

```{r}
seatbelts_long_2 <- melt.data.table(
  as.data.table(seatbelts), id.vars = NULL,
  measure.vars = c("DriversKilled", "front", "rear"),
  variable.name = "victim_type",
  value.name = "nvictims"
)
head(seatbelts_long_2)
```

```{r}
seatbelts_long_3 <- cdata::unpivot_to_blocks(
  seatbelts, nameForNewKeyColumn = "victim_type",
  nameForNewValueColumn = "nvictims",
  columnsToTakeFrom = c("DriversKilled", "front", "rear")
)
seatbelts_long_3 %>% arrange(victim_type, date) %>% head()
```

```{r}
seatbelts_long_1 <- tidyr::gather(
  seatbelts,
  key = victim_type,
  value = nvictims,
  DriversKilled, front, rear
)
head(seatbelts_long_1)
```

```{r}
seatbelts_long <- tidyr::pivot_longer(
  seatbelts, c(DriversKilled, front, rear),
  names_to = "victim_type",
  values_to = "nvictims",
)
head(arrange(seatbelts_long, victim_type))
```


```{r pracr-5-eng-6}
ggplot(seatbelts_long_1, aes(x = date, y = nvictims,
                             color = law, shape = law)) +
  geom_point() +
  geom_smooth(se = F) +
  facet_wrap(~ victim_type, ncol = 1, scale = "free_y") +
  ggtitle("UK auto fatalities by month and seating posision")
```

## Tall to wide

```{r}
chick_weight <- data.frame(ChickWeight)
chick_weight$Diet <- NULL
padz <- function(x, n = max(nchar(x))) gsub(" ", "0", formatC(x, width = n))
chick_weight$Chick <- paste0("Chick", padz(as.character(chick_weight$Chick)))
head(chick_weight)
```

```{r}
chick_summary <- as.data.table(chick_weight)
chick_summary <- chick_summary[, .(count = .N,
                     weight = mean(weight),
                     q1_weight = quantile(weight, probs = 0.25),
                     q2_weight = quantile(weight, probs = 0.75)),
              by = Time]
head(chick_summary)
```

```{r}
chick_summary <- cdata::unpivot_to_blocks(
  chick_summary,
  nameForNewKeyColumn = "measurement",
  nameForNewValueColumn = "value",
  columnsToTakeFrom = c("count", "weight")
)
chick_summary$q1_weight[chick_summary$measurement == "count"] <- NA
chick_summary$q2_weight[chick_summary$measurement == "count"] <- NA
cw <- ChickWeight
cw$measurement <- "weight"
```

```{r pracr-5-eng-7}
ggplot(chick_summary, aes(x = Time, y = value, color = measurement)) +
  geom_line(data = cw, aes(x = Time, y = weight, group = Chick),
            color = "lightgrey") +
  geom_line(linewidth = 2) +
  geom_ribbon(aes(ymin = q1_weight, ymax = q2_weight),
              alpha = 0.3, color = NA) +
  facet_wrap(~ measurement, ncol = 1, scales = "free_y") +
  theme(legend.position = "none") +
  ylab(NULL) +
  ggtitle("Chick Weight and Count Measurements by Time",
          subtitle = "25% through 75% quartiles of weight shown shaded around mean")
```

> `dcast.data.table()`

```{r}
chick_weight_wide2 <- dcast.data.table(
  as.data.table(chick_weight),
  Chick ~ Time,
  value.var = "weight"
)
head(chick_weight_wide2)
class(chick_weight_wide2)
```

> `cdata::pivot_to_rowrecs()`

```{r}
chick_weight_wide3 <- cdata::pivot_to_rowrecs(
  chick_weight,
  columnToTakeKeysFrom = "Time",
  columnToTakeValuesFrom = "weight",
  rowKeyColumns = "Chick"
)
head(chick_weight_wide3)
class(chick_weight_wide3)
```

> `tidyr::spread()`

```{r}
chick_weight_wide1 <- tidyr::spread(
  chick_weight, key = Time, value = weight
)
head(chick_weight_wide1)
```

> `tidyr::pivot_wider()`

```{r}
tidyr::pivot_wider(
  chick_weight, names_from = Time, values_from = weight
)
```


